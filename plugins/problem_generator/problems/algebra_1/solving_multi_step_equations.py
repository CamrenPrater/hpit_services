import random
from functools import reduce
from sympy import *
from plugins.problem_generator.utils import *


class SolvingEquationsWithTheDistributivePropertyAndByCombiningLikeTermsProblem:
    skill_name = "solving_equations_with_the_distributive_property_and_by_combining_like_terms"
    short_description = "Solving Equations With The Distributive Property And By Combining Like Terms"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingTwoStepEquationsSimpleValuesProblem:
    skill_name = "solving_two_step_equations_simple_values"
    short_description = "Solving Two Step Equations Simple Values"
    problem_enabled = False

    def __call__(self):
        return False



class WorkWordProblemsProblem:
    skill_name = "work_word_problems"
    short_description = "Work Word Problems"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingEquationsWithTheDistributivePropertyFirstStepProblem:
    skill_name = "solving_equations_with_the_distributive_property_first_step"
    short_description = "Solving Equations With The Distributive Property First Step"
    problem_enabled = False

    def __call__(self):
        return False



class WorkWordProblemsFindAnIndividualTimeProblem:
    skill_name = "work_word_problems_find_an_individual_time"
    short_description = "Work Word Problems Find An Individual Time"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingTwoStepEquationsVariableOnTheRightProblem:
    skill_name = "solving_two_step_equations_variable_on_the_right"
    short_description = "Solving Two Step Equations Variable On The Right"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingEquationsWithAbsoluteValuesIProblem:
    skill_name = "solving_equations_with_absolute_values_i"
    short_description = "Solving Equations With Absolute Values I"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingEquationsWithInequalitiesAndAbsoluteValuesProblem:
    skill_name = "solving_equations_with_inequalities_and_absolute_values"
    short_description = "Solving Equations With Inequalities And Absolute Values"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingEquationsWithTheDistributivePropertyProblem:
    skill_name = "solving_equations_with_the_distributive_property"
    short_description = "Solving Equations With The Distributive Property"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingEquationsByCombiningLikeTermsIProblem:
    skill_name = "solving_equations_by_combining_like_terms_i"
    short_description = "Solving Equations By Combining Like Terms I"
    problem_enabled = False

    def __call__(self):
        return False



class DirectAndIndirectVariationSquaredWordProblemsProblem:
    skill_name = "direct_and_indirect_variation_squared_word_problems"
    short_description = "Direct And Indirect Variation Squared Word Problems"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingRationalExpressionsIProblem:
    skill_name = "solving_rational_expressions_i"
    short_description = "Solving Rational Expressions I"
    problem_enabled = False

    def __call__(self):
        return False



class RateWordProblemsIiProblem:
    skill_name = "rate_word_problems_ii"
    short_description = "Rate Word Problems Ii"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingWithVariablesOnBothSidesProblem:
    skill_name = "solving_with_variables_on_both_sides"
    short_description = "Solving With Variables On Both Sides"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingAnEquationWordProblemProblem:
    skill_name = "solving_an_equation_word_problem"
    short_description = "Solving An Equation Word Problem"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingEquationsWithAbsoluteValuesIiProblem:
    skill_name = "solving_equations_with_absolute_values_ii"
    short_description = "Solving Equations With Absolute Values Ii"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingEquationsByCombiningLikeTermsIiProblem:
    skill_name = "solving_equations_by_combining_like_terms_ii"
    short_description = "Solving Equations By Combining Like Terms Ii"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingEquationsWithInequalitiesProblem:
    skill_name = "solving_equations_with_inequalities"
    short_description = "Solving Equations With Inequalities"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingForAVariableInTermsOfOtherVariablesMoreAdvancedProblem:
    skill_name = "solving_for_a_variable_in_terms_of_other_variables_more_advanced"
    short_description = "Solving For A Variable In Terms Of Other Variables More Advanced"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingTwoStepEquationsSimpleValuesNoNegativesProblem:
    skill_name = "solving_two_step_equations_simple_values_no_negatives"
    short_description = "Solving Two Step Equations Simple Values No Negatives"
    problem_enabled = False

    def __call__(self):
        return False



class RateWordProblemsIiiProblem:
    skill_name = "rate_word_problems_iii"
    short_description = "Rate Word Problems Iii"
    problem_enabled = False

    def __call__(self):
        return False



class DirectAndIndirectVariationWordProblemsProblem:
    skill_name = "direct_and_indirect_variation_word_problems"
    short_description = "Direct And Indirect Variation Word Problems"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingMultiStepEquationWordProblemProblem:
    skill_name = "solving_multi_step_equation_word_problem"
    short_description = "Solving Multi Step Equation Word Problem"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingForAVariableInTermsOfOtherVariablesProblem:
    skill_name = "solving_for_a_variable_in_terms_of_other_variables"
    short_description = "Solving For A Variable In Terms Of Other Variables"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingRationalExpressionsIiProblem:
    skill_name = "solving_rational_expressions_ii"
    short_description = "Solving Rational Expressions Ii"
    problem_enabled = False

    def __call__(self):
        return False



class RateWordProblemsIProblem:
    skill_name = "rate_word_problems_i"
    short_description = "Rate Word Problems I"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingWithVariablesOnBothSides1DigitProblem:
    skill_name = "solving_with_variables_on_both_sides_1_digit"
    short_description = "Solving With Variables On Both Sides 1 Digit"
    problem_enabled = False

    def __call__(self):
        return False



class SolvingTwoStepEquationsProblem:
    skill_name = "solving_two_step_equations"
    short_description = "Solving Two Step Equations"
    problem_enabled = True

    def __call__(self, depth=2, rounding=2):
        depth = convert_kwarg(depth, int)

        expression = symbols('x')
        for t in range(0, depth-1):
            exp_type = random.choice(['left', 'right', 'center_left', 'center_right'])

            if exp_type == 'left':
                expression = random_expression(expression)
            elif exp_type == 'right':
                expression = random_expression(None, expression)
            elif exp_type == 'center_left':
                expression = random_expression(expression, random_expression())
            elif exp_type == 'center_right':
                expression = random_expression(random_expression(), expression)

        expression = Eq(expression, random_tens_int(2))
        solution = solve(expression)

        if not solution:
            return self(depth, rounding)

        solution = solution[0]
        solution_1 = format_expression(solution)
        solution_2 = str(round(solution.evalf(), rounding))
        return "Solve for x: " + format_expression(expression), [solution_1, solution_2]

